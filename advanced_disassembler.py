"""
Geli≈ümi≈ü C64 PRG dosyasƒ± disassembler
- Basit opcode table (yeni, g√ºvenli)
- py65 tabanlƒ± (eski, g√º√ßl√º ama riskli)
- √áoklu dil √ßevirisi destekli
- Memory map entegrasyonu
üçé Advanced Disassembler v5.4 - Commodore 64 Geli≈ütirme St√ºdyosu - DEBUG MODE
================================================================
PROJE: Kƒ±zƒ±lElma Ana Plan - Enhanced Universal Disk Reader v2.0 ‚Üí C64 Development Studio
MOD√úL: advanced_disassembler.py - Geli≈ümi≈ü C64 Disassembler Motoru
VERSƒ∞YON: 5.4 (4 Disassembler Motor - "advanced" se√ßeneƒüi) - DEBUG MODE
AMA√á: Geli≈ümi≈ü C64 PRG dosyasƒ± disassembly ve √ßoklu format desteƒüi

üöÄ DEBUG GUIDE - COMPONENT CODES:
================================================================
[D1] AdvancedDisassembler - Ana sƒ±nƒ±f
[D2] disassemble_simple() - Basit disassembly (dƒ±≈ü kullanƒ±m)
[D3] disassemble_py65() - py65 disassembly (dƒ±≈ü kullanƒ±m)
[D4] disassemble() - Format se√ßimli ana disassembly
[D5] _disassemble_asm() - Native Assembly format
[D6] _disassemble_tass() - TASS format
[D7] _disassemble_kickassembler() - KickAssembler format
[D8] _disassemble_cc64() - CC64 format
[D9] _disassemble_simple() - ƒ∞√ß basit disassembly
[D10] _disassemble_py65() - ƒ∞√ß py65 disassembly
[D11] translate_instruction() - √áeviri motoru
[D12] load_memory_map() - Memory map y√ºkleyici
[D13] get_memory_info() - Memory bilgi alƒ±cƒ±
[D14] get_memory_label() - Memory label alƒ±cƒ±
[D15] convert_to_language() - Dil √ßevirici
[D16] to_c() - C √ßevirisi
[D17] to_qbasic() - QBasic √ßevirisi
[D18] to_pdsx() - PDSX √ßevirisi
[D19] to_commodore_basic_v2() - CBM Basic √ßevirisi
[D20] to_pseudo() - Pseudo-code √ßevirisi
================================================================

Bu mod√ºl 4 Disassembler Motor sisteminin "advanced" motorudur:
‚Ä¢ Geli≈ümi≈ü Opcode Table: G√ºvenli ve kapsamlƒ± disassembly
‚Ä¢ py65 Tabanlƒ± Motor: G√º√ßl√º ama riskli disassembly se√ßeneƒüi
‚Ä¢ √áoklu Dil √áevirisi: Assembly, C, QBasic, PDSX, Pseudo √ßƒ±kƒ±≈ü
‚Ä¢ Memory Map Entegrasyonu: C64 bellek haritasƒ± ile geli≈ümi≈ü etiketleme
‚Ä¢ GUI Integration: 4 Disassembler dropdown'ƒ±nda "advanced" se√ßeneƒüi

4 Disassembler Motor Sistemi:
1. basic - Temel disassembler
2. advanced - Bu mod√ºl (geli≈ümi≈ü √∂zellikler)
3. improved - C64 Enhanced disassembler  
4. py65_professional - Professional py65 tabanlƒ±
================================================================
"""

import json
import os
from opcode_manager import OpcodeManager
from improved_disassembler import ImprovedDisassembler
import disassembly_formatter

class AdvancedDisassembler:
    """[D1] Ana AdvancedDisassembler sƒ±nƒ±fƒ± - T√ºm disassembly i≈ülemlerinin merkezi"""
    
    def __init__(self, start_address, code, use_py65=False, use_illegal_opcodes=False, output_format='tass'):
        """[D1.1] Constructor - Disassembler'ƒ± ba≈ülat"""
        # DEBUG mode flag - √∂nce tanƒ±mla
        self.debug_mode = True
        
        self.start_address = start_address
        self.code = code
        self.use_py65 = use_py65
        self.use_illegal_opcodes = use_illegal_opcodes
        self.output_format = output_format  # 'asm', 'c', 'qbasic', 'pseudo'
        self.opcode_manager = OpcodeManager()
        self.opcodes = self.opcode_manager.get_all_opcodes()
        self.translations = self.opcode_manager.get_all_translations()
        self.memory_map = self.load_memory_map()  # [D12] √ßaƒürƒ±sƒ±
        
        # [D1.2] py65 desteƒüi
        if use_py65:
            try:
                from py65.devices.mpu6502 import MPU
                from py65.memory import ObservableMemory
                from py65.disassembler import Disassembler as PY65Disassembler
                self.memory = ObservableMemory()
                self.mpu = MPU(self.memory)  # Memory'yi MPU'ya ge√ß
                self.py65_disassembler = PY65Disassembler(self.mpu)
                self.py65_available = True
                if self.debug_mode:
                    print("[D1.2] ‚úÖ py65 disassembler y√ºklendi")
            except ImportError as e:
                self.py65_available = False
                if self.debug_mode:
                    print(f"[D1.2] ‚ùå py65 k√ºt√ºphanesi y√ºklenemedi: {e}")
        else:
            self.py65_available = False
            if self.debug_mode:
                print("[D1.2] ‚ÑπÔ∏è py65 kullanƒ±lmƒ±yor")
    
    def load_memory_map(self):
        """[D12] Memory map'i y√ºkle"""
        if self.debug_mode:
            print("[D12] üîÑ Memory map y√ºkleniyor...")
            
        memory_map = {}
        json_path = os.path.join(os.path.dirname(__file__), "memory_map.json")
        
        if os.path.exists(json_path):
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    
                # String hex deƒüerlerini int'e √ßevir
                for hex_str, description in data.items():
                    if hex_str.startswith('0x'):
                        address = int(hex_str, 16)
                        memory_map[address] = description
                        
                if self.debug_mode:
                    print(f"[D12] ‚úÖ Memory map y√ºklendi: {len(memory_map)} adres")
                
            except Exception as e:
                if self.debug_mode:
                    print(f"[D12] ‚ùå Memory map y√ºkleme hatasƒ±: {e}")
        else:
            if self.debug_mode:
                print(f"[D12] ‚ö†Ô∏è Memory map dosyasƒ± bulunamadƒ±: {json_path}")
                
        return memory_map
    
    def get_memory_info(self, address):
        """[D13] Belirli bir adres i√ßin memory map bilgisi al"""
        if self.debug_mode:
            print(f"[D13] üîç Memory info aranƒ±yor: ${address:04X}")
            
        if address in self.memory_map:
            info = self.memory_map[address]
            if self.debug_mode:
                print(f"[D13] ‚úÖ Bulundu: {info}")
            return info
        
        if self.debug_mode:
            print(f"[D13] ‚ùå Memory info bulunamadƒ±")
        return None
    
    def translate_instruction(self, opcode_name, operand_value=None, operand_2=None):
        """[D11] Instruction'ƒ± belirtilen formata √ßevir"""
        if self.debug_mode:
            print(f"[D11] üîÑ √áeviri: {opcode_name} -> {self.output_format}")
            
        if self.output_format == 'asm':
            if self.debug_mode:
                print("[D11] ‚ÑπÔ∏è Assembly format - √ßeviri yok")
            return None  # Assembly format i√ßin √ßeviri yok
        
        # √áeviri tablosunda varsa kullan
        if opcode_name in self.translations:
            # Format'a g√∂re doƒüru key'i kullan
            if self.output_format == 'c':
                translation_key = 'c_equivalent'
            elif self.output_format == 'qbasic':
                translation_key = 'qbasic_equivalent'
            elif self.output_format == 'pdsx':
                translation_key = 'pdsx_equivalent'
            elif self.output_format == 'pseudo':
                translation_key = 'pseudo_equivalent'
            elif self.output_format == 'commodorebasicv2':
                translation_key = 'commodorebasicv2_equivalent'
            else:
                translation_key = f"{self.output_format}_equivalent"
            
            translation = self.translations[opcode_name].get(translation_key, None)
            
            if translation:
                if self.debug_mode:
                    print(f"[D11] ‚úÖ √áeviri bulundu: {translation}")
                    
                # Operand deƒüerlerini yerine koy
                if operand_value is not None:
                    # √ñnce b√ºy√ºk harflerle dene
                    if 'ADDRESS' in translation:
                        translation = translation.replace('ADDRESS', str(operand_value))
                    elif 'ADDR' in translation:
                        translation = translation.replace('ADDR', str(operand_value))
                    elif 'address' in translation:
                        translation = translation.replace('address', str(operand_value))
                    elif 'addr' in translation:
                        translation = translation.replace('addr', str(operand_value))
                    elif 'VALUE' in translation:
                        translation = translation.replace('VALUE', str(operand_value))
                    elif 'value' in translation:
                        translation = translation.replace('value', str(operand_value))
                    elif 'label' in translation:
                        translation = translation.replace('label', f"label_{operand_value:04X}")
                    elif 'LABEL' in translation:
                        translation = translation.replace('LABEL', f"label_{operand_value:04X}")
                
                return translation
            else:
                if self.debug_mode:
                    print(f"[D11] ‚ö†Ô∏è √áeviri bulunamadƒ±: {translation_key}")
        
        # Fallback: Bilinmeyen opcode'lar i√ßin basit √ßeviri
        if self.debug_mode:
            print(f"[D11] üîÑ Fallback √ßeviri kullanƒ±lƒ±yor")
            
        if self.output_format == 'c':
            if operand_value is not None:
                return f"/* {opcode_name} {operand_value} */"
            else:
                return f"/* {opcode_name} */"
        elif self.output_format in ['qbasic', 'pdsx', 'commodorebasicv2']:
            if operand_value is not None:
                return f"REM {opcode_name} {operand_value}"
            else:
                return f"REM {opcode_name}"
        else:
            if operand_value is not None:
                return f"// {opcode_name} {operand_value}"
            else:
                return f"// {opcode_name}"

    def disassemble_simple(self, prg_data):
        """[D2] Basit disassemble metodu - dƒ±≈ü kullanƒ±m i√ßin"""
        if self.debug_mode:
            print(f"[D2] üöÄ Basit disassemble ba≈ülatƒ±lƒ±yor - Format: {self.output_format}")
            
        if not prg_data or len(prg_data) < 2:
            if self.debug_mode:
                print("[D2] ‚ùå Ge√ßersiz PRG verisi")
            return "Hata: Ge√ßersiz PRG verisi"
        
        # Eƒüer format assembly deƒüilse, yeni improved disassembler kullan
        if self.output_format != 'asm':
            if self.debug_mode:
                print("[D2] üîÑ ImprovedDisassembler kullanƒ±lƒ±yor")
            improved_disasm = ImprovedDisassembler(self.start_address, self.code, self.output_format)
            return improved_disasm.disassemble_to_format(prg_data)
        
        if self.debug_mode:
            print("[D2] üîÑ Assembly format - eski metod kullanƒ±lƒ±yor")
            
        # Assembly format i√ßin eski metod
        # PRG dosyasƒ±nƒ±n ba≈ülangƒ±√ß adresini al
        start_addr = prg_data[0] + (prg_data[1] << 8)
        code_data = prg_data[2:]
        
        if self.debug_mode:
            print(f"[D2] üìç Start Address: ${start_addr:04X}, Code Size: {len(code_data)} bytes")
        
        # Ge√ßici olarak parametreleri g√ºncelle
        old_start = self.start_address
        old_code = self.code
        
        self.start_address = start_addr
        self.code = code_data
        
        result = self._disassemble_simple()  # [D9] √ßaƒürƒ±sƒ±
        
        # Eski parametreleri geri y√ºkle
        self.start_address = old_start
        self.code = old_code
        
        if self.debug_mode:
            print(f"[D2] ‚úÖ Disassemble tamamlandƒ± - {len(result)} satƒ±r")
        
        return '\n'.join(result)
        
    def disassemble_py65(self, prg_data):
        """[D3] py65 disassemble metodu - dƒ±≈ü kullanƒ±m i√ßin"""
        if self.debug_mode:
            print(f"[D3] üöÄ py65 disassemble ba≈ülatƒ±lƒ±yor")
            
        if not prg_data or len(prg_data) < 2:
            if self.debug_mode:
                print("[D3] ‚ùå Ge√ßersiz PRG verisi")
            return "Hata: Ge√ßersiz PRG verisi"
            
        # PRG dosyasƒ±nƒ±n ba≈ülangƒ±√ß adresini al
        start_addr = prg_data[0] + (prg_data[1] << 8)
        code_data = prg_data[2:]
        
        if self.debug_mode:
            print(f"[D3] üìç Start Address: ${start_addr:04X}, Code Size: {len(code_data)} bytes")
        
        # Ge√ßici olarak parametreleri g√ºncelle
        old_start = self.start_address
        old_code = self.code
        
        self.start_address = start_addr
        self.code = code_data
        
        result = self._disassemble_py65()  # [D10] √ßaƒürƒ±sƒ±
        
        # Eski parametreleri geri y√ºkle
        self.start_address = old_start
        self.code = old_code
        
        if self.debug_mode:
            print(f"[D3] ‚úÖ py65 disassemble tamamlandƒ± - {len(result)} satƒ±r")
        
        return '\n'.join(result)

    def disassemble(self):
        """[D4] Disassembler metodu - se√ßilen yazƒ±m tarzƒ±na g√∂re √ßƒ±ktƒ± √ºretir"""
        if self.debug_mode:
            print(f"[D4] üöÄ Format se√ßimli disassemble: {self.output_format}")
            
        if self.output_format == 'asm':
            if self.debug_mode:
                print("[D4] üîÑ [D5] _disassemble_asm() √ßaƒürƒ±lƒ±yor")
            return self._disassemble_asm()
        elif self.output_format == 'tass':
            if self.debug_mode:
                print("[D4] üîÑ [D6] _disassemble_tass() √ßaƒürƒ±lƒ±yor")
            return self._disassemble_tass()
        elif self.output_format == 'kickassembler':
            if self.debug_mode:
                print("[D4] üîÑ [D7] _disassemble_kickassembler() √ßaƒürƒ±lƒ±yor")
            return self._disassemble_kickassembler()
        elif self.output_format == 'cc64':
            if self.debug_mode:
                print("[D4] üîÑ [D8] _disassemble_cc64() √ßaƒürƒ±lƒ±yor")
            return self._disassemble_cc64()
        else:
            if self.debug_mode:
                print(f"[D4] ‚ùå Desteklenmeyen format: {self.output_format}")
            raise ValueError(f"Desteklenmeyen √ßƒ±ktƒ± formatƒ±: {self.output_format}")

    def _disassemble_asm(self):
        """[D5] Standard Assembly format i√ßin disassembler (Native C64 Assembly)"""
        if self.debug_mode:
            print(f"[D5] üéØ Native Assembly disassemble ba≈ülatƒ±lƒ±yor")
            print(f"[D5] üìç Start: ${self.start_address:04X}, Size: {len(self.code)} bytes")
            
        lines = []
        lines.append(f"; Assembly Code - Start Address: ${self.start_address:04X}")
        lines.append(f"; Code Size: {len(self.code)} bytes")
        lines.append("")
        
        pc = self.start_address
        while pc < self.start_address + len(self.code):
            # Additional bounds check to prevent index errors
            if pc - self.start_address >= len(self.code):
                break
                
            opcode = self.code[pc - self.start_address]
            
            # Address prefix ekle
            address_line = f"{disassembly_formatter.format_address(pc)}: "
            
            if opcode in self.opcodes:
                template, length, mnemonic = self.opcodes[opcode]
                
                # Hex bytes g√∂ster
                hex_bytes = []
                for i in range(length):
                    if pc - self.start_address + i < len(self.code):
                        hex_bytes.append(f"{self.code[pc - self.start_address + i]:02X}")
                hex_str = " ".join(hex_bytes).ljust(8)  # 8 karakter geni≈ülik
                
                # Assembly instruksiyon olu≈ütur
                if length == 1:
                    instruction = f"{mnemonic}"
                elif length == 2:
                    # Bounds check for 2-byte instruction
                    if pc - self.start_address + 1 < len(self.code):
                        operand = self.code[pc - self.start_address + 1]
                        instruction = f"{mnemonic} ${operand:02X}"
                    else:
                        instruction = f"{mnemonic} ??   ; Missing operand byte"
                elif length == 3:
                    # Bounds check for 3-byte instruction
                    if pc - self.start_address + 2 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        operand_hi = self.code[pc - self.start_address + 2]
                        operand = operand_lo + (operand_hi << 8)
                        
                        # Memory map label kontrol√º
                        label = self.get_memory_label(operand)
                        if label:
                            instruction = f"{mnemonic} {label}"
                        else:
                            instruction = f"{mnemonic} ${operand:04X}"
                    elif pc - self.start_address + 1 < len(self.code):
                        # Only low byte available
                        operand_lo = self.code[pc - self.start_address + 1]
                        instruction = f"{mnemonic} ${operand_lo:02X}?? ; Missing high byte"
                    else:
                        instruction = f"{mnemonic} ????   ; Missing operand bytes"
                
                lines.append(f"{address_line}{hex_str} {instruction}")
                
                # Safe PC increment - don't go beyond available data
                pc += min(length, len(self.code) - (pc - self.start_address))
                
                # Additional safety check to prevent infinite loop
                if pc >= self.start_address + len(self.code):
                    break
            else:
                # Bilinmeyen opcode
                hex_str = f"{opcode:02X}".ljust(8)
                lines.append(f"{address_line}{hex_str} .BYTE ${opcode:02X}")
                pc += 1
        
        return lines

    def _disassemble_tass(self):
        """[D6] TASS yazƒ±m tarzƒ± i√ßin disassembler"""
        if self.debug_mode:
            print(f"[D6] üéØ TASS format disassemble ba≈ülatƒ±lƒ±yor")
            
        lines = []
        pc = self.start_address
        while pc < self.start_address + len(self.code):
            # Bounds check
            if pc - self.start_address >= len(self.code):
                break
                
            opcode = self.code[pc - self.start_address]
            if opcode in self.opcodes:
                template, length, mnemonic = self.opcodes[opcode]
                if length == 1:
                    lines.append(f"{mnemonic}")
                elif length == 2:
                    if pc - self.start_address + 1 < len(self.code):
                        operand = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} ${operand:02X}")
                    else:
                        lines.append(f"{mnemonic} ??")
                elif length == 3:
                    if pc - self.start_address + 2 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        operand_hi = self.code[pc - self.start_address + 2]
                        operand = operand_lo + (operand_hi << 8)
                        lines.append(f"{mnemonic} ${operand:04X}")
                    elif pc - self.start_address + 1 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} ${operand_lo:02X}??")
                    else:
                        lines.append(f"{mnemonic} ????")
                        
                # Safe PC increment
                pc += min(length, len(self.code) - (pc - self.start_address))
                if pc >= self.start_address + len(self.code):
                    break
            else:
                lines.append(f".BYTE ${opcode:02X}")
                pc += 1
        return lines

    def _disassemble_kickassembler(self):
        """[D7] KickAssembler yazƒ±m tarzƒ± i√ßin disassembler"""
        if self.debug_mode:
            print(f"[D7] üéØ KickAssembler format disassemble ba≈ülatƒ±lƒ±yor")
            
        lines = []
        pc = self.start_address
        while pc < self.start_address + len(self.code):
            if pc - self.start_address >= len(self.code):
                break
                
            opcode = self.code[pc - self.start_address]
            if opcode in self.opcodes:
                template, length, mnemonic = self.opcodes[opcode]
                if length == 1:
                    lines.append(f"{mnemonic}")
                elif length == 2:
                    if pc - self.start_address + 1 < len(self.code):
                        operand = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} #{operand:02X}")
                    else:
                        lines.append(f"{mnemonic} #??")
                elif length == 3:
                    if pc - self.start_address + 2 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        operand_hi = self.code[pc - self.start_address + 2]
                        operand = operand_lo + (operand_hi << 8)
                        lines.append(f"{mnemonic} #{operand:04X}")
                    elif pc - self.start_address + 1 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} #{operand_lo:02X}??")
                    else:
                        lines.append(f"{mnemonic} #????")
                        
                pc += min(length, len(self.code) - (pc - self.start_address))
                if pc >= self.start_address + len(self.code):
                    break
            else:
                lines.append(f".BYTE #{opcode:02X}")
                pc += 1
        return lines

    def _disassemble_cc64(self):
        """[D8] CC64 yazƒ±m tarzƒ± i√ßin disassembler"""
        if self.debug_mode:
            print(f"[D8] üéØ CC64 format disassemble ba≈ülatƒ±lƒ±yor")
            
        lines = []
        pc = self.start_address
        while pc < self.start_address + len(self.code):
            if pc - self.start_address >= len(self.code):
                break
                
            opcode = self.code[pc - self.start_address]
            if opcode in self.opcodes:
                template, length, mnemonic = self.opcodes[opcode]
                if length == 1:
                    lines.append(f"{mnemonic}")
                elif length == 2:
                    if pc - self.start_address + 1 < len(self.code):
                        operand = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} {operand:02X}h")
                    else:
                        lines.append(f"{mnemonic} ??h")
                elif length == 3:
                    if pc - self.start_address + 2 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        operand_hi = self.code[pc - self.start_address + 2]
                        operand = operand_lo + (operand_hi << 8)
                        lines.append(f"{mnemonic} {operand:04X}h")
                    elif pc - self.start_address + 1 < len(self.code):
                        operand_lo = self.code[pc - self.start_address + 1]
                        lines.append(f"{mnemonic} {operand_lo:02X}??h")
                    else:
                        lines.append(f"{mnemonic} ????h")
                        
                pc += min(length, len(self.code) - (pc - self.start_address))
                if pc >= self.start_address + len(self.code):
                    break
            else:
                lines.append(f".BYTE {opcode:02X}h")
                pc += 1
        return lines
    
    def _disassemble_simple(self):
        """[D9] Basit opcode table ile disassemble"""
        if self.debug_mode:
            print(f"[D9] üéØ Basit disassemble ba≈ülatƒ±lƒ±yor")
            
        if not self.code:
            return ["Hata: Kod verisi yok"]
        
        lines = []
        pc = self.start_address
        end_address = self.start_address + len(self.code)
        
        while pc < end_address:
            try:
                if pc - self.start_address >= len(self.code):
                    break
                    
                opcode = self.code[pc - self.start_address]
                
                if opcode in self.opcodes:
                    template, length, opcode_name = self.opcodes[opcode]
                    operand_value = None
                    
                    if length == 1:
                        disasm_text = template
                    elif length == 2:
                        if pc - self.start_address + 1 < len(self.code):
                            operand = self.code[pc - self.start_address + 1]
                            operand_value = operand
                            disasm_text = template % operand
                            
                            # Memory map kontrol√º (sadece assembly i√ßin)
                            if self.output_format == 'asm':
                                memory_info = self.get_memory_info(operand)
                                if memory_info:
                                    disasm_text += f" ; {memory_info}"
                        else:
                            disasm_text = f".BYTE ${opcode:02X}"
                    elif length == 3:
                        if pc - self.start_address + 2 < len(self.code):
                            operand_lo = self.code[pc - self.start_address + 1]
                            operand_hi = self.code[pc - self.start_address + 2]
                            operand = operand_lo + (operand_hi << 8)
                            operand_value = operand
                            disasm_text = template % operand
                            
                            # Memory map kontrol√º (sadece assembly i√ßin)
                            if self.output_format == 'asm':
                                memory_info = self.get_memory_info(operand)
                                if memory_info:
                                    disasm_text += f" ; {memory_info}"
                        else:
                            disasm_text = f".BYTE ${opcode:02X}"
                    
                    # Format'a g√∂re √ßeviri yap
                    if self.output_format != 'asm':
                        translation = self.translate_instruction(opcode_name, operand_value)
                        if translation:
                            # √áeviri ana kod olsun, assembly yorum olsun
                            if self.output_format == 'c':
                                disasm_text = f"{translation}  /* {disasm_text} */"
                            elif self.output_format == 'qbasic':
                                disasm_text = f"{translation}  REM {disasm_text}"
                            elif self.output_format == 'pdsx':
                                disasm_text = f"{translation}  REM {disasm_text}"
                            elif self.output_format == 'commodorebasicv2':
                                disasm_text = f"{translation}  REM {disasm_text}"
                            elif self.output_format == 'pseudo':
                                disasm_text = f"{translation}  // {disasm_text}"
                            else:
                                disasm_text = f"{translation}  /* {disasm_text} */"
                        
                        lines.append(f"{disasm_text}")
                    else:
                        # Assembly format i√ßin address ile beraber
                        lines.append(f"${pc:04X}: {disasm_text}")
                    
                    pc += length
                else:
                    # Bilinmeyen opcode - sabit √ßeviri
                    if self.output_format == 'asm':
                        lines.append(f"${pc:04X}: .BYTE ${opcode:02X}")
                    else:
                        # Bilinmeyen opcode'lar i√ßin format'a g√∂re sabit √ßeviri
                        if self.output_format == 'c':
                            lines.append(f"/* Unknown opcode: 0x{opcode:02X} */")
                        elif self.output_format == 'qbasic':
                            lines.append(f"REM Unknown opcode: 0x{opcode:02X}")
                        elif self.output_format == 'pdsx':
                            lines.append(f"REM Unknown opcode: 0x{opcode:02X}")
                        elif self.output_format == 'commodorebasicv2':
                            lines.append(f"REM Unknown opcode: 0x{opcode:02X}")
                        elif self.output_format == 'pseudo':
                            lines.append(f"// Unknown opcode: 0x{opcode:02X}")
                        else:
                            lines.append(f"/* Unknown opcode: 0x{opcode:02X} */")
                    pc += 1
                    
            except Exception as e:
                lines.append(f"{disassembly_formatter.format_address(pc)}: HATA - {e}")
                pc += 1
        
        return lines
    
    def _disassemble_py65(self):
        """[D10] py65 ile disassemble (eski method)"""
        if self.debug_mode:
            print(f"[D10] üéØ py65 disassemble ba≈ülatƒ±lƒ±yor")
            
        try:
            # Memory'ye kodu y√ºkle
            self.memory[self.start_address:self.start_address + len(self.code)] = self.code
            
            lines = []
            pc = self.start_address
            end_address = self.start_address + len(self.code)
            
            while pc < end_address:
                try:
                    # py65 disassembler kullan
                    length, disasm_text = self.py65_disassembler.instruction_at(pc)
                    lines.append(f"{disassembly_formatter.format_address(pc)}: {disasm_text}")
                    pc += length
                    
                except Exception as e:
                    # Fallback: Basit disassemble
                    opcode = self.memory[pc]
                    if opcode in self.opcodes:
                        length = self.opcodes[opcode][1]
                        lines.append(f"{disassembly_formatter.format_address(pc)}: .BYTE ${opcode:02X}")
                    else:
                        lines.append(f"{disassembly_formatter.format_address(pc)}: .BYTE ${opcode:02X}")
                        length = 1
                    pc += length
                    
            return lines
            
        except Exception as e:
            return [f"py65 Hatasƒ±: {e}"]
    
    def _get_instruction_length(self, opcode):
        """Instruction uzunluƒüunu hesapla"""
        if opcode in self.opcodes:
            return self.opcodes[opcode][1]
        return 1
    
    def convert_to_language(self, asm_lines, target_language):
        """[D15] Assembly'yi ba≈üka dillere √ßevir"""
        if self.debug_mode:
            print(f"[D15] üîÑ Dil √ßevirisi: {target_language}")
            
        if not asm_lines:
            return []
        
        converted = []
        
        for line in asm_lines:
            try:
                # Assembly satƒ±rƒ±nƒ± parse et
                if ':' in line:
                    addr_part, inst_part = line.split(':', 1)
                    addr = addr_part.strip()
                    instruction = inst_part.strip()
                    
                    # Opcode'u √ßƒ±kar
                    opcode_name = instruction.split()[0] if instruction else ""
                    
                    # √áeviri yap
                    translation = self.opcode_manager.get_translation(opcode_name, target_language)
                    converted.append(f"{addr}: {translation}")
                else:
                    converted.append(f"// {line}")
                    
            except Exception as e:
                converted.append(f"// √áeviri hatasƒ±: {line}")
        
        return converted
    
    def to_c(self, asm_lines):
        """[D16] C diline √ßevir"""
        if self.debug_mode:
            print(f"[D16] üîÑ C diline √ßeviri")
        return self.convert_to_language(asm_lines, "c")
    
    def to_qbasic(self, asm_lines):
        """[D17] QBasic'e √ßevir"""
        if self.debug_mode:
            print(f"[D17] üîÑ QBasic'e √ßeviri")
        return self.convert_to_language(asm_lines, "qbasic")
    
    def to_pdsx(self, asm_lines):
        """[D18] PDSX'e √ßevir"""
        if self.debug_mode:
            print(f"[D18] üîÑ PDSX'e √ßeviri")
        return self.convert_to_language(asm_lines, "pdsx")
    
    def to_commodore_basic_v2(self, asm_lines):
        """[D19] Commodore BASIC V2'ye √ßevir"""
        if self.debug_mode:
            print(f"[D19] üîÑ Commodore BASIC V2'ye √ßeviri")
        return self.convert_to_language(asm_lines, "commodorebasicv2")
    
    def to_pseudo(self, asm_lines):
        """[D20] Pseudo-code'a √ßevir"""
        if self.debug_mode:
            print(f"[D20] üîÑ Pseudo-code'a √ßeviri")
        return self.convert_to_language(asm_lines, "pseudo")
    
    def get_memory_label(self, address):
        """[D14] Memory map'ten label al"""
        if self.debug_mode:
            print(f"[D14] üîç Memory label aranƒ±yor: ${address:04X}")
            
        try:
            # JSON verisini DataLoader √ºzerinden y√ºkle
            from data_loader import DataLoader
            loader = DataLoader(os.path.dirname(__file__))
            
            # Memory maps ve zeropage verilerini y√ºkle
            mem_maps = loader.load_directory('c64_rom_data/memory_maps')
            zero_maps = loader.load_directory('c64_rom_data/zeropage')
            
            # √ñnce zeropage deƒüi≈ükenlerini kontrol et
            for key, data in zero_maps.get('zeropage_vars', {}).items():
                try:
                    addr = int(key.replace('$', ''), 16)
                    if addr == address:
                        name = data.get('name', '')
                        return name.upper() if name else None
                except:
                    continue
            
            # Sonra memory map'i kontrol et
            for key, data in mem_maps.get('c64_memory_map', {}).items():
                try:
                    start_addr = int(key.replace('$', ''), 16)
                    end_addr_str = data.get('end_addr', key)
                    end_addr = int(end_addr_str.replace('$', ''), 16)
                    
                    if start_addr <= address <= end_addr:
                        name = data.get('name', '')
                        return name.replace(' ', '_').upper() if name else None
                except:
                    continue
            
            # ROM routines ve KERNAL calls
            rom_data = loader.load_directory('c64_rom_data')
            kernal_routines = rom_data.get('kernal_routines', {})
            basic_routines = rom_data.get('basic_routines', {})
            
            addr_hex = f"${address:04X}"
            if addr_hex in kernal_routines:
                name = kernal_routines[addr_hex].get('name', '')
                return name.upper() if name else None
            
            if addr_hex in basic_routines:
                name = basic_routines[addr_hex].get('name', '')
                return name.upper() if name else None
            
            return None
            
        except Exception as e:
            if self.debug_mode:
                print(f"[D14] JSON label y√ºkleme hatasƒ±: {e}")
            return None
    
    # === DEBUG VE TEST FONKSƒ∞YONLARI ===
    
    def debug_toggle(self, enable=None):
        """[DEBUG] Debug modunu a√ß/kapat"""
        if enable is None:
            self.debug_mode = not self.debug_mode
        else:
            self.debug_mode = enable
        print(f"[DEBUG] Debug mode: {'A√áIK' if self.debug_mode else 'KAPALI'}")
    
    def debug_info(self):
        """[DEBUG] Genel debug bilgilerini g√∂ster"""
        print("=" * 60)
        print("üçé ADVANCED DISASSEMBLER DEBUG INFO")
        print("=" * 60)
        print(f"[D1] Start Address: ${self.start_address:04X}")
        print(f"[D1] Code Size: {len(self.code)} bytes")
        print(f"[D1] Output Format: {self.output_format}")
        print(f"[D1] Use py65: {self.use_py65}")
        print(f"[D1] py65 Available: {self.py65_available}")
        print(f"[D1] Use Illegal Opcodes: {self.use_illegal_opcodes}")
        print(f"[D1] Debug Mode: {self.debug_mode}")
        print(f"[D12] Memory Map Entries: {len(self.memory_map)}")
        print(f"[D1] Opcodes Available: {len(self.opcodes)}")
        print(f"[D1] Translations Available: {len(self.translations)}")
        print("=" * 60)
    
    def debug_test_opcodes(self, count=10):
        """[DEBUG] ƒ∞lk N opcode'u test et"""
        print(f"[DEBUG] ƒ∞lk {count} opcode test ediliyor...")
        for i in range(min(count, len(self.code))):
            opcode = self.code[i]
            addr = self.start_address + i
            
            if opcode in self.opcodes:
                template, length, mnemonic = self.opcodes[opcode]
                print(f"[D-TEST] ${addr:04X}: {opcode:02X} -> {mnemonic} (len:{length})")
            else:
                print(f"[D-TEST] ${addr:04X}: {opcode:02X} -> UNKNOWN")
    
    def debug_memory_map_sample(self, count=5):
        """[DEBUG] Memory map √∂rnekleri g√∂ster"""
        print(f"[DEBUG] Memory map √∂rnekleri (ilk {count}):")
        items = list(self.memory_map.items())[:count]
        for addr, info in items:
            print(f"[D12] ${addr:04X}: {info}")
    
    def test_translation(self, opcode_name, target_format=None):
        """[DEBUG] Belirli bir opcode √ßevirisini test et"""
        if target_format:
            old_format = self.output_format
            self.output_format = target_format
        
        print(f"[D11-TEST] Testing {opcode_name} -> {self.output_format}")
        result = self.translate_instruction(opcode_name, 0x1234)
        print(f"[D11-TEST] Result: {result}")
        
        if target_format:
            self.output_format = old_format
        
        return result

# Geriye uyumluluk i√ßin eski API
class Disassembler:
    def __init__(self, start_address, code):
        self.advanced = AdvancedDisassembler(start_address, code, use_py65=False)
    
    def disassemble(self):
        return self.advanced.disassemble()

# py65 destekli versiyon
class PY65Disassembler:
    def __init__(self, start_address, code):
        self.advanced = AdvancedDisassembler(start_address, code, use_py65=True)
    
    def disassemble(self):
        return self.advanced.disassemble()

if __name__ == "__main__":
    # üöÄ DEBUG MODE TEST RUNNER
    print("üçé Advanced Disassembler v5.4 - DEBUG MODE")
    print("=" * 60)
    
    # Test kodu
    test_code = [0xA9, 0x00, 0x85, 0x02, 0x60]  # LDA #$00, STA $02, RTS
    
    print("=== [D1] Basic Test - Constructor ===")
    disasm = Disassembler(0xC000, test_code)
    for line in disasm.disassemble():
        print(line)
    
    print("\n=== [D1] Advanced Disassembler Test ===")
    advanced = AdvancedDisassembler(0xC000, test_code)
    
    # Debug bilgilerini g√∂ster
    print("\n=== [DEBUG] Info ===")
    advanced.debug_info()
    
    print("\n=== [DEBUG] Opcode Test ===")
    advanced.debug_test_opcodes(5)
    
    print("\n=== [DEBUG] Memory Map Sample ===")
    advanced.debug_memory_map_sample(3)
    
    print("\n=== [D5] Assembly Disassembly ===")
    asm_lines = advanced.disassemble()
    for line in asm_lines:
        print(line)
    
    print("\n=== [D16] C Translation Test ===")
    advanced.test_translation("LDA", "c")
    c_lines = advanced.to_c(asm_lines)
    for line in c_lines:
        print(line)
    
    print("\n=== [D17] QBasic Translation Test ===")
    advanced.test_translation("STA", "qbasic")
    qbasic_lines = advanced.to_qbasic(asm_lines)
    for line in qbasic_lines:
        print(line)
    
    # Debug mode toggle test
    print("\n=== [DEBUG] Mode Toggle Test ===")
    advanced.debug_toggle(False)
    advanced.debug_toggle(True)
    
    print("\nüéØ Test tamamlandƒ±! T√ºm componentler [D1-D20] √ßalƒ±≈üƒ±yor.")
    print("üí° Artƒ±k component kodlarƒ± ile kolayca ileti≈üim kurabiliriz!")
