"""
DASM Format Plugin
==================

Author: Enhanced AI System
Plugin Type: Format
Description: DASM assembler format desteği
Version: 1.0.0
"""

from typing import Dict, Any
import re
import sys
import os

# Plugin Manager import path düzeltmesi
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from plugin_manager import IFormatPlugin, PluginMetadata, PluginType
except ImportError:
    # Fallback için base classes
    from abc import ABC, abstractmethod
    from enum import Enum
    from dataclasses import dataclass
    
    class PluginType(Enum):
        FORMAT = "format"
    
    @dataclass
    class PluginMetadata:
        name: str
        version: str
        author: str
        description: str
        plugin_type: PluginType
        dependencies: list
        entry_point: str
    
    class IFormatPlugin(ABC):
        @abstractmethod
        def get_metadata(self): pass
        @abstractmethod
        def initialize(self, context): pass
        @abstractmethod
        def cleanup(self): pass
        @abstractmethod
        def get_format_name(self): pass
        @abstractmethod
        def format_assembly(self, assembly_code, options=None): pass
        @abstractmethod
        def parse_assembly(self, formatted_code): pass
        @abstractmethod
        def execute(self, *args, **kwargs): pass

class DASMFormatPlugin(IFormatPlugin):
    """DASM Assembler Format Plugin"""
    
    def get_metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="dasm_format",
            version="1.0.0",
            author="Enhanced AI System",
            description="DASM assembler format plugin with 6502 support",
            plugin_type=PluginType.FORMAT,
            dependencies=[],
            entry_point="DASMFormatPlugin"
        )
    
    def initialize(self, context: Dict[str, Any]) -> bool:
        self.context = context
        self.dasm_directives = {
            'ORG': 'org',
            'EQU': 'equ', 
            'DC.B': 'dc.b',
            'DC.W': 'dc.w',
            'DS.B': 'ds.b',
            'DS.W': 'ds.w',
            'INCLUDE': 'include',
            'INCBIN': 'incbin'
        }
        
        self.register_patterns = {
            'A': r'\bA\b',
            'X': r'\bX\b', 
            'Y': r'\bY\b',
            'SP': r'\bSP\b'
        }
        
        return True
    
    def cleanup(self) -> None:
        pass
    
    def get_format_name(self) -> str:
        return "DASM"
    
    def format_assembly(self, assembly_code: str, options: Dict[str, Any] = None) -> str:
        """Assembly kodunu DASM formatına çevir"""
        if not assembly_code:
            return ""
            
        lines = assembly_code.split('\n')
        formatted_lines = []
        
        # DASM header ekle
        formatted_lines.append("; DASM Format Assembly")
        formatted_lines.append("; Generated by DASM Format Plugin")
        formatted_lines.append("")
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith(';'):
                formatted_lines.append(line)
                continue
            
            # Format the line according to DASM conventions
            formatted_line = self._format_dasm_line(line)
            formatted_lines.append(formatted_line)
        
        return '\n'.join(formatted_lines)
    
    def _format_dasm_line(self, line: str) -> str:
        """Tek satırı DASM formatına çevir"""
        # Label check
        if ':' in line:
            parts = line.split(':', 1)
            label = parts[0].strip()
            rest = parts[1].strip() if len(parts) > 1 else ""
            
            if rest:
                return f"{label}:\n    {rest}"
            else:
                return f"{label}:"
        
        # Directive conversion
        for std_dir, dasm_dir in self.dasm_directives.items():
            if line.upper().startswith(std_dir):
                line = line.replace(std_dir, dasm_dir.upper(), 1)
                break
        
        # Add proper indentation for instructions
        if not line.startswith(' ') and not line.endswith(':'):
            line = "    " + line
        
        # DASM syntax adjustments
        line = self._adjust_dasm_syntax(line)
        
        return line
    
    def _adjust_dasm_syntax(self, line: str) -> str:
        """DASM syntax düzeltmeleri"""
        # Immediate addressing - DASM uses #
        line = re.sub(r'(\w+)\s+#(\$[0-9A-Fa-f]+|\d+)', r'\1 #\2', line)
        
        # Zero page addressing
        line = re.sub(r'(\w+)\s+(\$[0-9A-Fa-f]{1,2})\b', r'\1 \2', line)
        
        # Absolute addressing  
        line = re.sub(r'(\w+)\s+(\$[0-9A-Fa-f]{3,4})\b', r'\1 \2', line)
        
        # Indexed addressing
        line = re.sub(r'(\w+)\s+(\$[0-9A-Fa-f]+),X', r'\1 \2,X', line)
        line = re.sub(r'(\w+)\s+(\$[0-9A-Fa-f]+),Y', r'\1 \2,Y', line)
        
        # Indirect addressing
        line = re.sub(r'(\w+)\s+\((\$[0-9A-Fa-f]+)\)', r'\1 (\2)', line)
        line = re.sub(r'(\w+)\s+\((\$[0-9A-Fa-f]+),X\)', r'\1 (\2,X)', line)
        line = re.sub(r'(\w+)\s+\((\$[0-9A-Fa-f]+)\),Y', r'\1 (\2),Y', line)
        
        return line
    
    def parse_assembly(self, formatted_code: str) -> Dict[str, Any]:
        """DASM formatlanmış assembly'yi parse et"""
        lines = formatted_code.split('\n')
        parsed_data = {
            "labels": [],
            "instructions": [],
            "directives": [],
            "comments": [],
            "success": True,
            "format": "DASM"
        }
        
        current_address = 0
        
        for line_no, line in enumerate(lines, 1):
            line = line.strip()
            
            if not line:
                continue
                
            # Comment line
            if line.startswith(';'):
                parsed_data["comments"].append({
                    "line": line_no,
                    "comment": line[1:].strip()
                })
                continue
            
            # Label
            if line.endswith(':'):
                label = line[:-1].strip()
                parsed_data["labels"].append({
                    "line": line_no,
                    "label": label,
                    "address": current_address
                })
                continue
            
            # Directive
            if any(line.upper().startswith(directive.upper()) for directive in self.dasm_directives.values()):
                parsed_data["directives"].append({
                    "line": line_no,
                    "directive": line,
                    "address": current_address
                })
                
                # Address update for ORG
                if line.upper().startswith('ORG'):
                    try:
                        addr_part = line.split()[1]
                        if addr_part.startswith('$'):
                            current_address = int(addr_part[1:], 16)
                        else:
                            current_address = int(addr_part)
                    except:
                        pass
                continue
            
            # Instruction
            if line.strip():
                parsed_data["instructions"].append({
                    "line": line_no,
                    "instruction": line.strip(),
                    "address": current_address
                })
                current_address += 1  # Approximate
        
        return parsed_data
    
    def execute(self, *args, **kwargs) -> Any:
        """Plugin'in ana işlevi"""
        if args:
            return self.format_assembly(*args, **kwargs)
        return {"status": "ready", "format": "DASM"}

# Plugin class'ını export et
__all__ = ['DASMFormatPlugin']
